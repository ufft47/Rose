#include "global.hpp"
#include "game_config.hpp"
#include "filesystem.hpp"
#include "language.hpp"
#include "loadscreen.hpp"
#include "editor.hpp"
// #include <sys/stat.h>
#include "display.hpp"
#include "wml_exception.hpp"
#include "gettext.hpp"
#include "gui/dialogs/message.hpp"
#include "serialization/parser.hpp"
#include "formula_string_utils.hpp"
#include "sdl_filesystem.h"

#include "animation.hpp"
#include "builder.hpp"

#include <iomanip>
#include <boost/foreach.hpp>
#include <boost/bind.hpp>

const std::string studio_guid = "3641E31E-36BF-4E03-8879-DE33ADC07D68";
const std::string apps_sln_guid = "8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942";

void tapp_capabilities::generate2(std::stringstream& ss, const std::string& prefix) const
{
	VALIDATE(bundle_id.valid(), null_str);

	ss.str("");
	ss << "#\n";
	ss << "# NOTE: it is generated by rose studio, don't edit yourself.\n";
	ss << "#\n";
	ss << "\n";

	if (app != bundle_id.node(2)) {
		ss << prefix << "app = " << app << "\n";
	}
	ss << prefix << "bundle_id = \"" << bundle_id.id() << "\"\n";
	if (ble) {
		ss << prefix << "ble = yes\n";
	}
	if (healthkit) {
		ss << prefix << "healthkit = yes\n";
	}

	if (tdomains.size() > 1) {
		std::stringstream extra_textdomain;
		const std::string app_lib = app + "-lib";
		for (std::set<std::string>::const_iterator it = tdomains.begin(); it != tdomains.end(); ++ it) {
			const std::string& domain = *it;
			if (domain != app_lib) {
				if (!extra_textdomain.str().empty()) {
					extra_textdomain << ", ";
				}
				extra_textdomain << domain;
			}
		}
		ss << prefix << "extra_textdomain = " << extra_textdomain.str() << "\n";
	}

	if (path_ != "..") {
		ss << prefix << "path = " << path_ << "\n";
	}
}

bool is_apps_kit(const std::string& res_folder)
{
	// 1. resource directory
	const std::string APPS_RES = "apps-res";
	size_t pos = res_folder.find(APPS_RES);
	if (pos == std::string::npos || pos + APPS_RES.size() != res_folder.size()) {
		return false;
	}

	// 2. code directory
	const std::string& src_folder = game_config::apps_src_path;
	const std::string APPS_SRC = "apps-src";
	pos = src_folder.find(APPS_SRC);
	if (pos == std::string::npos || pos + APPS_SRC.size() != src_folder.size()) {
		return false;
	}

	// 3. apps.sln
	if (!apps_sln::apps_in(src_folder + "/apps").size()) {
		return false;
	}

	return true;
}

// private app will not in <apps-res>/absolute/apps.cfg
bool is_private_app(const std::string& app)
{
	static std::set<std::string> private_apps;
	if (private_apps.empty()) {
		private_apps.insert("studio");
	}

	return private_apps.find(app) != private_apps.end();
}

// reserve app can not be removed.
bool is_reserve_app(const std::string& app)
{
	static std::set<std::string> reserve_apps;
	if (reserve_apps.empty()) {
		reserve_apps.insert("blesmart");
		reserve_apps.insert("editor");
		reserve_apps.insert("kingdom");
		reserve_apps.insert("sleep");
		reserve_apps.insert("sesame");
		reserve_apps.insert("studio");
	}

	return reserve_apps.find(app) != reserve_apps.end();
}

namespace apps_sln {

std::string sln_from_src2_path(const std::string& src2_path)
{
	const std::string app = file_name(src2_path);
	bool is_work_kit = app == "apps";

	VALIDATE(!game_config::apps_src_path.empty(), null_str);
	return src2_path + "/projectfiles/vc/" + (is_work_kit? "apps.sln": (app + ".sln"));
}

std::map<std::string, std::string> apps_in(const std::string& src2_path)
{
	std::map<std::string, std::string> apps;
	std::stringstream ss;

	const std::string sln = sln_from_src2_path(src2_path);

	tfile file(sln,  GENERIC_READ, OPEN_EXISTING);
	int fsize = file.read_2_data();
	if (!fsize) {
		return apps;
	}
	// i think length of appended data isn't more than 512 bytes.
	file.resize_data(fsize + 512, fsize);
	file.data[fsize] = '\0';

	const char* start2 = file.data;
	if (utils::bom_magic_started((const uint8_t*)file.data, fsize)) {
		start2 += BOM_LENGTH;
	}

	// studio
	ss.str("");
	ss << "Project(\"{" << apps_sln_guid << "}\") = \"";
	std::string prefix = ss.str();
	const char* ptr = NULL;
	{
		ptr = strstr(start2, prefix.c_str());
		while (ptr) {
			ptr += prefix.size();
			start2 = strchr(ptr, '\"');
			VALIDATE(start2, null_str);

			const std::string app(ptr, start2 - ptr);

			ptr = strchr(start2, '{');
			VALIDATE(ptr, null_str);
			ptr ++;
			start2 = strchr(ptr, '}');
			VALIDATE(start2, null_str);
			const std::string guid(ptr, start2 - ptr);

			apps.insert(std::make_pair(app, guid));
			ptr = strstr(start2, prefix.c_str());
		}
	}

	return apps;
}

bool add_project(const std::string& app, const std::string& guid_str)
{
	std::set<std::string> apps;
	std::stringstream ss;

	VALIDATE(!game_config::apps_src_path.empty(), null_str);
	const std::string sln = game_config::apps_src_path + "/apps/projectfiles/vc/apps.sln";

	tfile file(sln, GENERIC_WRITE, OPEN_EXISTING);
	int fsize = file.read_2_data();
	if (!fsize) {
		return false;
	}
	// i think length of appended data isn't more than 512 bytes.
	file.resize_data(fsize + 512, fsize);
	file.data[fsize] = '\0';

	const char* start2 = file.data;
	if (utils::bom_magic_started((const uint8_t*)file.data, fsize)) {
		start2 += BOM_LENGTH;
	}

	// insert project at end
	std::string prefix = "EndProject";
	std::string postfix = "Global";
	const char* ptr = strstr(start2, prefix.c_str());
	while (ptr) {
		const char* ptr2 = utils::skip_blank_characters(ptr + prefix.size());
		if (!SDL_strncmp(ptr2, postfix.c_str(), postfix.size())) {
			std::stringstream ss;
			ss << "Project(\"{" << apps_sln_guid << "}\") = \"" << app << "\", \"" << app << ".vcxproj\", \"{" << guid_str << "}\"";
			ss << "\r\n";
			ss << "EndProject";
			ss << "\r\n";
			fsize = file.replace_span(ptr2 - file.data, 0, ss.str().c_str(), ss.str().size(), fsize);
			break;
		}
		ptr = strstr(ptr2, prefix.c_str());
	}

	// insert configuration
	prefix = "= postSolution";
	ptr = strstr(start2, prefix.c_str());
	if (ptr) {
		postfix = "EndGlobalSection";
		ptr = strstr(ptr, postfix.c_str());
		if (ptr) {
			ptr -= 1; // \t
		}
	}
	if (ptr) {
		std::stringstream ss;
		ss << "\t\t{" << guid_str << "}.Debug|Win32.ActiveCfg = Debug|Win32" << "\r\n";
		ss << "\t\t{" << guid_str << "}.Debug|Win32.Build.0 = Debug|Win32" << "\r\n";
		ss << "\t\t{" << guid_str << "}.Release|Win32.ActiveCfg = Release|Win32" << "\r\n";
		ss << "\t\t{" << guid_str << "}.Release|Win32.Build.0 = Release|Win32" << "\r\n";
		fsize = file.replace_span(ptr - file.data, 0, ss.str().c_str(), ss.str().size(), fsize);
	}

	// write data to new file
	posix_fseek(file.fp, 0);
	posix_fwrite(file.fp, file.data, fsize);

	return true;
}

bool remove_project(const std::string& app)
{
	std::set<std::string> apps;
	std::stringstream ss;

	VALIDATE(!game_config::apps_src_path.empty(), null_str);
	const std::string sln = game_config::apps_src_path + "/apps/projectfiles/vc/apps.sln";

	// const std::string sln3 = game_config::apps_src_path + "/apps/projectfiles/vc/apps.sln3";
	// SDL_CopyFiles(sln.c_str(), sln3.c_str());

	tfile file(sln,  GENERIC_WRITE, OPEN_EXISTING);
	int fsize = file.read_2_data();
	if (!fsize) {
		return false;
	}
	// i think length of appended data isn't more than 512 bytes.
	file.resize_data(fsize + 512, fsize);
	file.data[fsize] = '\0';

	const char* start2 = file.data;
	if (utils::bom_magic_started((const uint8_t*)file.data, fsize)) {
		start2 += BOM_LENGTH;
	}

	// studio
	ss.str("");
	ss << "Project(\"{" << apps_sln_guid << "}\") = \"" << app << "\"";
	std::string prefix = ss.str();
	const char* ptr = strstr(start2, prefix.c_str());
	if (!ptr) {
		return false;
	}
	ptr = strchr(ptr + prefix.size(), '{');
	VALIDATE(ptr, null_str);

	start2 = ptr + 1;
	ptr = strchr(start2, '}');

	const std::string guid_str(start2, ptr - start2);
	const int guid_size2 = 36;
	VALIDATE(guid_str.size() == guid_size2, null_str);
	start2 += guid_str.size();
	// move start2 to first char of this line
	while (start2[0] != '\r' && start2[0] != '\n') { start2 --; }
	start2 ++;

	//
	// delete like below lines:
	// Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "hello", "hello.vcxproj", "{43FDDD3E-D26A-4F52-B207-8DC03CB25396}"
	// EndProject
	//

	prefix = "EndProject";
	ptr = strstr(ptr, prefix.c_str());
	if (!ptr) {
		return false;
	}
	ptr += prefix.size();
	// move ptr to first char of next line.
	while (ptr[0] != '\r' && ptr[0] != '\n') { ptr ++; }
	while (ptr[0] == '\r' || ptr[0] == '\n') { ptr ++; }
	fsize = file.replace_span(start2 - file.data, ptr - start2, NULL, 0, fsize);

	// remove items in GlobalSection
	ss.str("");
	ss << "{" << guid_str << "}";
	prefix = ss.str();

	ptr = strstr(start2, prefix.c_str());
	if (!ptr) {
		return false;
	}
	start2 = ptr - 1;
	while (start2[0] == '\t' || start2[0] == ' ') { start2 --; }
	// start indicate postion that from delete.
	const char* start = start2 + 1;

	// move start2 to last line that has guid_str.
	while (ptr) {
		start2 = ptr;
		ptr = strstr(start2 + prefix.size(), prefix.c_str());
	}

	// move ptr to first char of next line.
	ptr = start2 + prefix.size();
	while (ptr[0] != '\r' && ptr[0] != '\n') { ptr ++; }
	while (ptr[0] == '\r' || ptr[0] == '\n') { ptr ++; }

	fsize = file.replace_span(start - file.data, ptr - start, NULL, 0, fsize);

	// write data to new file
	posix_fseek(file.fp, 0);
	posix_fwrite(file.fp, file.data, fsize);

	file.truncate(fsize);

	return true;
}

bool can_new_dialog(const std::string& app)
{
	std::set<std::string> apps;
	std::stringstream ss;

	VALIDATE(!game_config::apps_src_path.empty() && !app.empty(), null_str);

	{
		const std::string vcxproj = game_config::apps_src_path + "/apps/projectfiles/vc/" + app + ".vcxproj";
		tfile file(vcxproj, GENERIC_READ, OPEN_EXISTING);
		int fsize = file.read_2_data();
		if (!fsize) {
			return false;
		}
		// i think length of appended data isn't more than 512 bytes.
		file.resize_data(fsize + 512, fsize);
		file.data[fsize] = '\0';

		const char* start2 = file.data;
		if (utils::bom_magic_started((const uint8_t*)file.data, fsize)) {
			start2 += BOM_LENGTH;
		}

		// <ClCompile Include="..\..\studio\main.cpp"
		std::string prefix = "<ClCompile Include=\"..\\..\\" + app + "\\main.cpp\"";
		const char* ptr = strstr(start2, prefix.c_str());
		if (!ptr) {
			return false;
		}
	}

	{
		const std::string filters = game_config::apps_src_path + "/apps/projectfiles/vc/" + app + ".vcxproj.filters";
		tfile file(filters, GENERIC_READ, OPEN_EXISTING);
		int fsize = file.read_2_data();
		if (!fsize) {
			return false;
		}
		// i think length of appended data isn't more than 512 bytes.
		file.resize_data(fsize + 512, fsize);
		file.data[fsize] = '\0';

		const char* start2 = file.data;
		if (utils::bom_magic_started((const uint8_t*)file.data, fsize)) {
			start2 += BOM_LENGTH;
		}

		std::vector<std::string> must_filters;
		must_filters.push_back("Source Files");
		must_filters.push_back("Header Files");
		must_filters.push_back("gui\\dialogs");

		for (std::vector<std::string>::const_iterator it = must_filters.begin(); it != must_filters.end(); ++ it) {
			// <Filter Include="gui\dialogs">
			std::string prefix = "<Filter Include=\"" + *it + "\">";
			const char* ptr = strstr(start2, prefix.c_str());
			if (!ptr) {
				return false;
			}
		}
	}
	return true;
}

int append_at_ItemGroup_end(tfile& file, const char* ptr, const int fsize, const std::string& str)
{
	const std::string prefix = "</ItemGroup>";
	const char* start2 = strstr(ptr, prefix.c_str());
	VALIDATE(start2, null_str);

	while (start2[0] != '\r' && start2[0] != '\n') { start2 --; }
	start2 ++;

	return file.replace_span(start2 - file.data, 0, str.c_str(), str.size(), fsize);
}

// @start2: this file's start pointer.
// @ptr: previous pointer.
const char* insert_hpp_ItemGroup(tfile& file, const char* start2, const std::string& app, int& fsize)
{
	std::string prefix = "<ClInclude Include=\"";
	const char* ptr2 = strstr(start2, prefix.c_str());
	if (!ptr2) {
		// there is no ItemGroup save .hpp, create it.
		// always create after the ItemGroup contain main.cpp.
		std::string prefix = "<ClCompile Include=\"..\\..\\" + app + "\\main.cpp\"";
		const char* ptr = strstr(start2, prefix.c_str());
		VALIDATE(ptr, null_str); // sorry, must conatin main.cpp.

		prefix = "</ItemGroup>\r\n";
		ptr = strstr(ptr, prefix.c_str());
		VALIDATE(ptr, null_str);
		ptr += prefix.size();

		std::stringstream ss;
		//  <ItemGroup>
		//  </ItemGroup>
		ss << "  <ItemGroup>\r\n";
		ss << "  </ItemGroup>\r\n";
		fsize = file.replace_span(ptr - file.data, 0, ss.str().c_str(), ss.str().size(), fsize);
		ptr2 = ptr + ss.str().size() - prefix.size();
	}
	return ptr2;
}

static std::pair<std::string, bool> generate_insert_string(const std::string& app, const std::string& file, const bool filters)
{
	bool cpp = true;
	const std::string file2 = utils::normalize_path(file, false);
	VALIDATE(file2.size() > 4, null_str);

	size_t pos = file2.rfind(".hpp");
	if (pos == file2.size() - 4) {
		cpp = false;
	} else {
		pos = file2.rfind(".cpp");
		VALIDATE(pos == file2.size() - 4, null_str);
	}

	const std::string dir = directory_name2(file2);
	std::stringstream ss;
	if (!filters) {
		if (cpp) {
			//    <ClCompile Include="..\..\studio\gui\dialogs\control_setting.cpp">
			//      <ObjectFileName Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)gui\dialogs\</ObjectFileName>
			//      <ObjectFileName Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)gui\dialogs\</ObjectFileName>
			//      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
			//      </ExcludedFromBuild>
			//    </ClCompile>
			if (dir.empty()) {
				ss << "    <ClCompile Include=\"..\\..\\" << app << "\\" << file2 << "\" />\r\n";
			} else {
				ss << "    <ClCompile Include=\"..\\..\\" << app << "\\" << file2 << "\">\r\n";
				ss << "      <ObjectFileName Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">$(IntDir)" << dir << "\\</ObjectFileName>\r\n";
				ss << "      <ObjectFileName Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">$(IntDir)" << dir << "\\</ObjectFileName>\r\n";
				ss << "      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\r\n";
				ss << "      </ExcludedFromBuild>\r\n";
				ss << "    </ClCompile>\r\n";
			}

		} else {
			//    <ClInclude Include="..\..\studio\gui\dialogs\cell_setting.hpp" />
			ss << "    <ClInclude Include=\"..\\..\\" << app << "\\" << file2 << "\" />\r\n";
		}
		
	} else {
		// const std::string filter = "Source Files";
		std::string filter = dir;
		if (filter.empty()) {
			filter = cpp? "Source Files": "Header Files";
		}

		if (cpp) {
			//    <ClCompile Include="..\..\studio\gui\dialogs\control_setting.cpp">
			//      <Filter>gui\dialogs</Filter>
			//    </ClCompile>
			ss << "    <ClCompile Include=\"..\\..\\" << app << "\\" << file2 << "\">\r\n";
			ss << "      <Filter>" << filter << "</Filter>\r\n";
			ss << "    </ClCompile>\r\n";
		} else {
			// .hpp
			//    <ClInclude Include="..\..\studio\gui\dialogs\cell_setting.hpp">
			//      <Filter>gui\dialogs</Filter>
			//    </ClInclude>
			ss << "    <ClInclude Include=\"..\\..\\" << app << "\\" << file2 << "\">\r\n";
			ss << "      <Filter>" << filter << "</Filter>\r\n";
			ss << "    </ClInclude>\r\n";
		}
	}
	return std::make_pair(ss.str(), cpp);
}

bool new_dialog(const std::string& app, const std::vector<std::string>& files)
{
	std::set<std::string> apps;

	VALIDATE(!game_config::apps_src_path.empty() && !app.empty() && !files.empty(), null_str);

	const std::string vcxproj = game_config::apps_src_path + "/apps/projectfiles/vc/" + app + ".vcxproj";
	const std::string vcxproj_tmp = game_config::preferences_dir + "/__tmp";
	
	{
		SDL_CopyFiles(vcxproj.c_str(), vcxproj_tmp.c_str());
		tfile file(vcxproj_tmp, GENERIC_WRITE, OPEN_EXISTING);
		int fsize = file.read_2_data();
		if (!fsize) {
			return false;
		}
		// i think length of appended data isn't more than 512 bytes.
		file.resize_data(fsize + 512, fsize);
		file.data[fsize] = '\0';

		const char* start2 = file.data;
		if (utils::bom_magic_started((const uint8_t*)file.data, fsize)) {
			start2 += BOM_LENGTH;
		}

		// <ClCompile Include="..\..\studio\main.cpp"
		std::string prefix = "<ClCompile Include=\"..\\..\\" + app + "\\main.cpp\"";
		const char* cpp_ptr = strstr(start2, prefix.c_str());
		if (!cpp_ptr) {
			return false;
		}

		for (std::vector<std::string>::const_iterator it = files.begin(); it != files.end(); ++ it) {
			std::pair<std::string, bool> pair = generate_insert_string(app, *it, false);
			const char* ptr = nullptr;
			if (!pair.second) {
				// .hpp
				ptr = insert_hpp_ItemGroup(file, start2, app, fsize);
			} else {
				ptr = cpp_ptr;
			}
			fsize = append_at_ItemGroup_end(file, ptr, fsize, pair.first);
		}
		posix_fseek(file.fp, 0);
		posix_fwrite(file.fp, file.data, fsize);
	}

	{
		const std::string filters = game_config::apps_src_path + "/apps/projectfiles/vc/" + app + ".vcxproj.filters";
		tfile file(filters, GENERIC_WRITE, OPEN_EXISTING);

		// SDL_CopyFiles(filters.c_str(), vcxproj_tmp.c_str());
		// tfile file(vcxproj_tmp, GENERIC_WRITE, OPEN_EXISTING);

		int fsize = file.read_2_data();
		if (!fsize) {
			return false;
		}
		// i think length of appended data isn't more than 512 bytes.
		file.resize_data(fsize + 512, fsize);
		file.data[fsize] = '\0';

		const char* start2 = file.data;
		if (utils::bom_magic_started((const uint8_t*)file.data, fsize)) {
			start2 += BOM_LENGTH;
		}

		// <ClCompile Include="..\..\studio\main.cpp"
		std::string prefix = "<ClCompile Include=\"..\\..\\" + app + "\\main.cpp\"";
		const char* cpp_ptr = strstr(start2, prefix.c_str());
		if (!cpp_ptr) {
			return false;
		}

		for (std::vector<std::string>::const_iterator it = files.begin(); it != files.end(); ++ it) {
			std::pair<std::string, bool> pair = generate_insert_string(app, *it, true);
			const char* ptr = nullptr;
			if (!pair.second) {
				// .hpp
				ptr = insert_hpp_ItemGroup(file, start2, app, fsize);
			} else {
				ptr = cpp_ptr;
			}
			fsize = append_at_ItemGroup_end(file, ptr, fsize, pair.first);
		}
		posix_fseek(file.fp, 0);
		posix_fwrite(file.fp, file.data, fsize);
	}
	SDL_CopyFiles(vcxproj_tmp.c_str(), vcxproj.c_str());
	SDL_DeleteFiles(vcxproj_tmp.c_str());

	return true;
}

}

bool check_res_folder(const std::string& folder)
{
	std::stringstream ss;
	
	// <wok>\data\_main.cfg
	ss << folder << "\\data\\_main.cfg";
	if (!file_exists(ss.str())) {
		return false;
	}

	return true;
}

bool check_apps_src_folder(const std::string& folder)
{
	std::stringstream ss;
	
	ss << folder << "/apps/projectfiles/vc/apps.sln";
	if (!file_exists(ss.str())) {
		return false;
	}

	return true;
}

struct tcopy_cookie
{
	tcopy_cookie(const std::string& dir)
		: current_path(dir)
	{
		char c = current_path.at(current_path.size() - 1);
		if (c == '\\' || c == '/') {
			current_path.erase(current_path.size() - 1);
		}
	}

	bool cb_copy_cookie(const std::string& dir, const SDL_dirent2* dirent);

	std::string current_path;
};

bool tcopy_cookie::cb_copy_cookie(const std::string& dir, const SDL_dirent2* dirent)
{
	if (SDL_DIRENT_DIR(dirent->mode)) {
		tcopy_cookie ccp2(current_path + "/" + dirent->name);
		const std::string cookie_cki = "__cookie.cki";
		{
			tfile lock(ccp2.current_path + "/" + cookie_cki, GENERIC_WRITE, CREATE_ALWAYS);
		}

		if (!walk_dir(ccp2.current_path, false, boost::bind(&tcopy_cookie::cb_copy_cookie, &ccp2, _1, _2))) {
			return false;
		}
	}
	return true;
}

bool is_studio_app(const std::string& app)
{
	return app == "studio";
}

int file_delete_line(tfile& file, const char* ptr, int& fsize)
{
	// start
	int start = ptr - file.data;
	while (file.data[start] != '\r' && file.data[start] != '\n' && start > 0) {
		start --;
	}
	if (file.data[start] == '\r' || file.data[start] == '\n') {
		start ++;
	}

	int stop = ptr - file.data;
	while (file.data[stop] != '\r' && file.data[stop] != '\n' && stop < fsize) {
		stop ++;
	}
	while ((file.data[stop] == '\r' || file.data[stop] == '\n') && stop < fsize) {
		stop ++;
	}
	fsize = file.replace_span(start, stop - start, NULL, 0, fsize);

	return start;
}



const std::string tapp_copier::windows_prj_alias = "windows_prj";
const std::string tapp_copier::android_prj_alias = "android_prj";
const std::string tapp_copier::ios_prj_alias = "ios_prj";
const std::string tapp_copier::app_windows_prj_alias = "app_windows_prj";
const std::string tapp_copier::app_android_prj_alias = "app_android_prj";
const std::string tapp_copier::app_ios_prj_alias = "app_ios_prj";

tapp_copier::tapp_copier(const config& cfg, const std::string& _app)
	: tapp_capabilities(cfg)
{
	if (app.empty()) {
		app = _app;
	}
	if (!bundle_id.valid()) {
		VALIDATE(!app.empty(), null_str);
		bundle_id.reset("com.leagor." + app);
	}
	VALIDATE(bundle_id.valid(), null_str);
	if (app.empty()) {
		app = bundle_id.node(2);
	}

	tdomains.insert(app + "-lib");

	std::vector<std::string> extra_tdomains = utils::split(cfg["extra_textdomain"].str());
	for (std::vector<std::string>::const_iterator it = extra_tdomains.begin(); it != extra_tdomains.end(); ++ it) {
		tdomains.insert(*it);
	}
}

void tapp_copier::app_complete_paths(std::map<std::string, std::string>& paths) const
{
	VALIDATE(!app.empty() && !paths.empty(), null_str);

	const std::string& res_path = ::alias_2_path(paths, ttask::res_alias);
	const std::string& src2_path = ::alias_2_path(paths, ttask::src2_alias);

	// app_res/app_src maybe overlay be *.cfg.
	VALIDATE(paths.find(ttask::app_res_alias) == paths.end(), null_str);
	VALIDATE(paths.find(ttask::app_src2_alias) == paths.end(), null_str);
	VALIDATE(paths.find(ttask::app_src_alias) == paths.end(), null_str);

	std::string app_res_path = res_path + "/" + path_;
	std::string app_src2_path = res_path + "/" + path_;
	if (is_studio_app(app)) {
		app_res_path += "/apps-res";
		app_src2_path += "/apps-src/apps";
	} else {
		app_res_path += "/" + app + "-res";
		app_src2_path += "/" + app + "-src/" + app;
	}
	app_res_path = utils::normalize_path(app_res_path);
	app_src2_path = utils::normalize_path(app_src2_path);

	VALIDATE(res_path != app_res_path && src2_path != app_src2_path, null_str);

	paths.insert(std::make_pair(ttask::app_res_alias, app_res_path));
	paths.insert(std::make_pair(ttask::app_src2_alias, app_src2_path));
	paths.insert(std::make_pair(ttask::app_src_alias, directory_name2(app_src2_path)));


	paths.insert(std::make_pair(windows_prj_alias, src2_path + "/projectfiles/windows-prj"));
	paths.insert(std::make_pair(app_windows_prj_alias, app_src2_path + "/projectfiles/vc"));
	paths.insert(std::make_pair(android_prj_alias, src2_path + "/projectfiles/android-prj"));
	paths.insert(std::make_pair(app_android_prj_alias, app_src2_path + "/projectfiles/android"));
	paths.insert(std::make_pair(ios_prj_alias, src2_path + "/projectfiles/ios-prj"));
	paths.insert(std::make_pair(app_ios_prj_alias, app_src2_path + "/projectfiles/Xcode-iOS"));
}


// const std::string& app_res_path = alias_2_path(app_res_alias)
// const std::string& app_ios_prj_path = alias_2_path(tapp_copier::app_ios_prj_alias)
static bool generate_ios_prj(display& disp, const tapp_copier& copier, const std::string& app_res_path, const std::string& app_ios_prj_path)
{
	const std::string app_in_prj = "studio";

	if (app_in_prj != copier.app) {
		// rename <app_ios_prj>/studio to <app_ios_prj>/<app>
		SDL_RenameFile((app_ios_prj_path + "/" + app_in_prj).c_str(), copier.app.c_str());
	}

	// rename <app_ios_prj>/studio.xcodeproj to <app_ios_prj>/<app>.xcodeproj
	const std::string app_xcodeproj = copier.app + ".xcodeproj";
	if (app_in_prj != copier.app) {
		SDL_RenameFile((app_ios_prj_path + "/" + app_in_prj + ".xcodeproj").c_str(), app_xcodeproj.c_str());
	}

	// <app_ios_prj>/<app>.xcodeproj/project.pbxproj
	const std::string pbxproj_tmp = "project.pbxproj.tmp";
	std::string src = app_ios_prj_path + "/" + app_xcodeproj + "/" + pbxproj_tmp;
	std::string dst = app_ios_prj_path + "/" + app_xcodeproj + "/project.pbxproj";
	SDL_RenameFile(dst.c_str(), pbxproj_tmp.c_str());
	{
		std::vector<std::string> vstr;
		tfile file(src, GENERIC_WRITE, OPEN_EXISTING);
		int fsize = file.read_2_data();
		if (!fsize) {
			return false;
		}
		// i think length of appended data isn't more than 512 bytes.
		file.resize_data(fsize + 512, fsize);
		file.data[fsize] = '\0';

		std::string prefix;
		const char* ptr = NULL;
		if (!copier.healthkit) {
			// delete all line that include "studio.entitlements"
			prefix = app_in_prj + ".entitlements";
			ptr = strstr(file.data, prefix.c_str());
			while (ptr) {
				int start = file_delete_line(file, ptr, fsize);
				ptr = NULL;
				if (start < fsize) {
					ptr = strstr(file.data + start, prefix.c_str());
				}
			}

			// delete SystemCapabilities = { }
			prefix = "SystemCapabilities = {";
			ptr = strstr(file.data, prefix.c_str());
			if (!ptr) {
				return false;
			}
			int start = ptr - file.data;
			while (file.data[start] != '\r' && file.data[start] != '\n' && start > 0) {
				start --;
			}
			if (file.data[start] == '\r' || file.data[start] == '\n') {
				start ++;
			}

			prefix = "};";
			for (int layer = 0; layer < 2; layer ++) {
				ptr = strstr(ptr, prefix.c_str());
				if (!ptr) {
					return false;
				}
				ptr += prefix.size();
			}
			int stop = ptr - file.data;
			while (file.data[stop] != '\r' && file.data[stop] != '\n' && stop < fsize) {
				stop ++;
			}
			while ((file.data[stop] == '\r' || file.data[stop] == '\n') && stop < fsize) {
				stop ++;
			}
			fsize = file.replace_span(start, stop - start, NULL, 0, fsize);
		}

		if (app_in_prj != copier.app) {
			// studio
			prefix = app_in_prj;
			ptr = strstr(file.data, prefix.c_str());
			while (ptr) {
				fsize = file.replace_span(ptr - file.data, prefix.size(), copier.app.c_str(), copier.app.size(), fsize);
				// replace next
				ptr = strstr(ptr, prefix.c_str());
			}
		}

		// PRODUCT_BUNDLE_IDENTIFIER, new bundle_id maybe include "studio", so place after replace app.
		prefix = "PRODUCT_BUNDLE_IDENTIFIER = ";
		ptr = strstr(file.data, prefix.c_str());
		while (ptr) {
			ptr = utils::skip_blank_characters(ptr + prefix.size());
			const char* ptr2 = utils::until_c_style_characters(ptr);
			fsize = file.replace_span(ptr - file.data, ptr2 - ptr, copier.bundle_id.id().c_str(), copier.bundle_id.size(), fsize);
			// replace next
			ptr = strstr(ptr, prefix.c_str());
		}

		// write data to new file
		tfile file2(dst, GENERIC_WRITE, CREATE_ALWAYS);
		if (file2.valid()) {
			posix_fseek(file2.fp, 0);
			posix_fwrite(file2.fp, file.data, fsize);
		}
	}
	SDL_DeleteFiles(src.c_str());

	// <app_ios_prj>/Info.plist
	const std::string plist_tmp = "Info.plist.tmp";
	src = app_ios_prj_path + "/" + plist_tmp;
	dst = app_ios_prj_path + "/Info.plist";
	SDL_RenameFile(dst.c_str(), plist_tmp.c_str());
	{
		std::vector<std::string> vstr;
		tfile file(src, GENERIC_WRITE, OPEN_EXISTING);
		int fsize = file.read_2_data();
		if (!fsize) {
			return false;
		}
		// i think length of appended data isn't more than 1024 bytes.
		file.resize_data(fsize + 1024, fsize);
		file.data[fsize] = '\0';

		std::string prefix;
		const char* ptr = NULL;
		if (!copier.healthkit) {
			// delete all line that include "studio.entitlements"
			prefix = "<string>healthkit</string>";
			ptr = strstr(file.data, prefix.c_str());
			while (ptr) {
				int start = file_delete_line(file, ptr, fsize);
				ptr = NULL;
				if (start < fsize) {
					ptr = strstr(file.data + start, prefix.c_str());
				}
			}
		}

		// write data to new file
		tfile file2(dst, GENERIC_WRITE, CREATE_ALWAYS);
		if (file2.valid()) {
			posix_fseek(file2.fp, 0);
			posix_fwrite(file2.fp, file.data, fsize);
		}
	}
	SDL_DeleteFiles(src.c_str());

	src = app_ios_prj_path + "/" + copier.app + "/" + app_in_prj + ".entitlements";
	if (copier.healthkit) {
		SDL_RenameFile(src.c_str(), (copier.app + ".entitlements").c_str());
	} else {
		SDL_DeleteFiles(src.c_str());
	}

	if (app_in_prj != copier.app) {
		// Images.xcassets
		src = app_res_path + "/" + game_config::generate_app_dir(copier.app) + "/Images.xcassets";
		dst = app_ios_prj_path + "/" + copier.app;
		SDL_CopyFiles(src.c_str(), dst.c_str());
	}

	return true;
}

void texporter::app_complete_paths()
{
	copier_.app_complete_paths(paths_);
}

bool texporter::app_post_handle(display& disp, const tsubtask& subtask, const bool last)
{
	if (!last) {
		return true;
	}

	if (!generate_window_prj(disp)) {
		return false;
	}

	if (!generate_android_prj(disp)) {
		return false;
	}

	if (!generate_ios_prj(disp, copier_, alias_2_path(app_res_alias), alias_2_path(tapp_copier::app_ios_prj_alias))) {
		return false;
	}

	return true;
}

std::vector<std::pair<std::string, std::string> > texporter::app_get_replace(const tsubtask& subtask)
{
	VALIDATE(!copier_.app.empty(), null_str);

	const std::string replacee = "<__app__>";
	return std::vector<std::pair<std::string, std::string> >(1, std::make_pair(replacee, copier_.app));
}

bool texporter::generate_window_prj(display& disp) const
{
	const std::string app_in_prj = "studio";
	bool is_apps = is_studio_app(copier_.app);

	const std::string& windows_prj_path = alias_2_path(tapp_copier::windows_prj_alias);
	const std::string& app_windows_prj_path = alias_2_path(tapp_copier::app_windows_prj_alias);

	// *.sln
	std::string src = windows_prj_path + "/apps.sln";
	std::string dst = app_windows_prj_path + "/" + (is_apps? "apps": copier_.app) + ".sln";
	std::string guid_str;
	{
		tfile file(app_windows_prj_path + "/" + copier_.app + ".vcxproj", GENERIC_READ, OPEN_EXISTING);
		int fsize = file.read_2_data();
		if (!fsize) {
			return false;
		}
		const char* start2 = file.data;
		if (utils::bom_magic_started((const uint8_t*)file.data, fsize)) {
			start2 += BOM_LENGTH;
		}

		// studio
		std::string prefix = "<ProjectGuid>{";
		const char* ptr = strstr(start2, prefix.c_str());
		if (!ptr) {
			return false;
		}
		std::string postfix = "}</ProjectGuid>";
		ptr += prefix.size();
		const char* ptr2 = strstr(ptr, postfix.c_str());
		const int guid_size2 = 36;
		guid_str.assign(ptr, ptr2 - ptr);
		if (guid_str.size() != guid_size2) {
			return false;
		}
	}
	{
		tfile file(src,  GENERIC_READ, OPEN_EXISTING);
		int fsize = file.read_2_data();
		if (!fsize) {
			return false;
		}
		// i think length of appended data isn't more than 512 bytes.
		file.resize_data(fsize + 512, fsize);
		file.data[fsize] = '\0';

		const char* start2 = file.data;
		if (utils::bom_magic_started((const uint8_t*)file.data, fsize)) {
			start2 += BOM_LENGTH;
		}

		// studio
		std::string prefix = app_in_prj;
		const char* ptr = NULL;
		if (prefix != copier_.app) {
			ptr = strstr(start2, prefix.c_str());
			while (ptr) {
				fsize = file.replace_span(ptr - file.data, prefix.size(), copier_.app.c_str(), copier_.app.size(), fsize);
				// replace next
				ptr = strstr(ptr, prefix.c_str());
			}
		}

		// guid of studio: 3641E31E-36BF-4E03-8879-DE33ADC07D68
		prefix = studio_guid;
		if (prefix != guid_str) {
			ptr = strstr(start2, prefix.c_str());
			while (ptr) {
				fsize = file.replace_span(ptr - file.data, prefix.size(), guid_str.c_str(), guid_str.size(), fsize);
				// replace next
				ptr = strstr(ptr, prefix.c_str());
			}
		}

		// write data to new file
		tfile file2(dst,  GENERIC_WRITE, CREATE_ALWAYS);
		if (file2.valid()) {
			posix_fseek(file2.fp, 0);
			posix_fwrite(file2.fp, file.data, fsize);
		}
	}

	// *.vcxproj.user
	src = windows_prj_path + "/" + app_in_prj + ".vcxproj.user";
	dst = app_windows_prj_path + "/" + copier_.app + ".vcxproj.user";

	std::vector<std::pair<std::string, std::string> > replaces;
	replaces.push_back(std::make_pair("apps-res", is_apps? "apps-res": copier_.app + "-res"));
	file_replace_string(src, dst, replaces);
	
	return true;
}

bool texporter::generate_android_prj(display& disp) const
{
	std::stringstream ss;
	const std::string app_in_prj = "studio";
	const tdomain default_bundle_id("com.leagor.studio");

	// <app_android_prj>/app/src/main/AndroidManifest.xml
	const std::string& app_android_prj_path = alias_2_path(tapp_copier::app_android_prj_alias);
	const std::string androidmanifest_xml_tmp = "AndroidManifest.xml.tmp";
	std::string src = app_android_prj_path + "/app/src/main/" + androidmanifest_xml_tmp;
	std::string dst = app_android_prj_path + "/app/src/main/AndroidManifest.xml";
	SDL_RenameFile(dst.c_str(), androidmanifest_xml_tmp.c_str());
	{
		tfile file(src, GENERIC_WRITE, OPEN_EXISTING);
		int fsize = file.read_2_data();
		if (!fsize) {
			return false;
		}
		// i think length of appended data isn't more than 512 bytes.
		file.resize_data(fsize + 512, fsize);
		file.data[fsize] = '\0';
		// replace with app's bundle id.
		const char* prefix = "\"http://schemas.android.com/apk/res/android\"";
		const char* ptr = strstr(file.data, prefix);
		if (!ptr) {
			return false;
		}
		ptr = utils::skip_blank_characters(ptr + strlen(prefix) + 1);
		if (memcmp(ptr, "package=\"", 9)) {
			return false;
		}
		ptr += 9;
		if (memcmp(ptr, default_bundle_id.id().c_str(), default_bundle_id.size())) {
			return false;
		}
		if (app_in_prj != copier_.app) {
			fsize = file.replace_span(ptr - file.data, default_bundle_id.size(), copier_.bundle_id.id().c_str(), copier_.bundle_id.size(), fsize);
		}
		file.data[fsize] = '\0';

		if (copier_.ble) {
			// insert ble permission.
			const char* prefix2 = "<uses-permission android:name=\"android.permission.MODIFY_AUDIO_SETTINGS\"/>";
			ptr = strstr(ptr, prefix2);
			if (!ptr) {
				return false;
			}
			ptr = utils::skip_blank_characters(ptr + strlen(prefix2) + 1);
			std::stringstream permission;
			permission << "<uses-permission android:name=\"android.permission.BLUETOOTH\" />\r\n";
			permission << "    <uses-permission android:name=\"android.permission.BLUETOOTH_ADMIN\" />\r\n";
			permission << "    <uses-permission android:name=\"android.permission.BLUETOOTH_PRIVILEGED\" />\r\n";
			permission << "    <uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\"/>\r\n";
			permission << "\r\n    ";
			fsize = file.replace_span(ptr - file.data, 0, permission.str().c_str(), permission.str().size(), fsize);
		}

		// write data to new file
		tfile file2(dst, GENERIC_WRITE, CREATE_ALWAYS);
		if (file2.valid()) {
			posix_fseek(file2.fp, 0);
			posix_fwrite(file2.fp, file.data, fsize);
		}
	}
	SDL_DeleteFiles(src.c_str());

	// <app_android_prj>/app/src/main/java/com/leagor/studio/app.java
	if (app_in_prj != copier_.app) {
		{
			ss.str("");
			ss << "/app/src/main/java/" + default_bundle_id.node(0) + "/" + default_bundle_id.node(1) + "/" + default_bundle_id.node(2) + "/app.java";
			tfile file(app_android_prj_path + ss.str(), GENERIC_WRITE, OPEN_EXISTING);
			int fsize = file.read_2_data();
			if (!fsize) {
				return false;
			}
			// i think length of appended data isn't more than 512 bytes.
			file.resize_data(fsize + 512, fsize);
			file.data[fsize] = '\0';
			// replace with app's bundle id.
			const char* prefix = "package";
			const char* ptr = strstr(file.data, prefix);
			if (!ptr) {
				return false;
			}
			ptr = utils::skip_blank_characters(ptr + strlen(prefix) + 1);
			fsize = file.replace_span(ptr - file.data, default_bundle_id.size(), copier_.bundle_id.id().c_str(), copier_.bundle_id.size(), fsize);

			std::string app_java_dir = app_android_prj_path + "/app/src/main/java/" + copier_.bundle_id.node(0) + "/" + copier_.bundle_id.node(1) + "/" + copier_.bundle_id.node(2);
			SDL_MakeDirectory(app_java_dir.c_str());
			tfile file2(app_java_dir + "/app.java", GENERIC_WRITE, CREATE_ALWAYS);
			posix_fwrite(file2.fp, file.data, fsize);
		}
		ss.str("");
		if (default_bundle_id.node(0) != copier_.bundle_id.node(0)) {
			ss << "/app/src/main/java/" + default_bundle_id.node(0);
		} else if (default_bundle_id.node(1) != copier_.bundle_id.node(1)) {
			ss << "/app/src/main/java/" + default_bundle_id.node(0) + "/" + default_bundle_id.node(1);
		} else {
			ss << "/app/src/main/java/" + default_bundle_id.node(0) + "/" + default_bundle_id.node(1) + "/" + default_bundle_id.node(2);
		}
		SDL_DeleteFiles((app_android_prj_path + ss.str()).c_str());
	}

	// <app_android_prj>/app/build.gradle
	if (app_in_prj != copier_.app) {
		const std::string build_gradle_tmp = "build.gradle.tmp";
		src = app_android_prj_path + "/app/" + build_gradle_tmp;
		dst = app_android_prj_path + "/app/build.gradle";
		SDL_RenameFile(dst.c_str(), build_gradle_tmp.c_str());
		{
			tfile file(src, GENERIC_WRITE, OPEN_EXISTING);
			int fsize = file.read_2_data();
			if (!fsize) {
				return false;
			}
			// i think length of appended data isn't more than 512 bytes.
			file.resize_data(fsize + 512, fsize);
			file.data[fsize] = '\0';
			// replace with app's bundle id.
			const char* prefix = "defaultConfig {";
			const char* ptr = strstr(file.data, prefix);
			if (!ptr) {
				return false;
			}
			ptr = utils::skip_blank_characters(ptr + strlen(prefix) + 1);
			if (memcmp(ptr, "applicationId", 13)) {
				return false;
			}
			ptr += 13;
			ptr = utils::skip_blank_characters(ptr);
			if (ptr[0] != '\"') {
				return false;
			}
			ptr ++;
			if (memcmp(ptr, default_bundle_id.id().c_str(), default_bundle_id.size())) {
				return false;
			}
			fsize = file.replace_span(ptr - file.data, default_bundle_id.size(), copier_.bundle_id.id().c_str(), copier_.bundle_id.size(), fsize);
			file.data[fsize] = '\0';

			// write data to new file
			tfile file2(dst, GENERIC_WRITE, CREATE_ALWAYS);
			if (file2.valid()) {
				posix_fseek(file2.fp, 0);
				posix_fwrite(file2.fp, file.data, fsize);
			}
		}
		SDL_DeleteFiles(src.c_str());
	}

	// <android-prj>/app/src/main/res/values/strings.xml
	if (app_in_prj != copier_.app) {
		const std::string strings_xml_tmp = "strings.xml.tmp";
		src = app_android_prj_path + "/app/src/main/res/values/" + strings_xml_tmp;
		dst = app_android_prj_path + "/app/src/main/res/values/strings.xml";
		SDL_RenameFile(dst.c_str(), strings_xml_tmp.c_str());
		{
			tfile file(src, GENERIC_WRITE, OPEN_EXISTING);
			int fsize = file.read_2_data();
			if (!fsize) {
				return false;
			}
			// i think length of appended data isn't more than 512 bytes.
			file.resize_data(fsize + 512, fsize);
			file.data[fsize] = '\0';
			// replace with app's bundle id.
			const char* prefix = "<string name=\"app_name\">";
			const char* ptr = strstr(file.data, prefix);
			if (!ptr) {
				return false;
			}
			ptr = utils::skip_blank_characters(ptr + strlen(prefix));
			fsize = file.replace_span(ptr - file.data, app_in_prj.size(), copier_.app.c_str(), copier_.app.size(), fsize);

			// write data to new file
			tfile file2(dst, GENERIC_WRITE, CREATE_ALWAYS);
			if (file2.valid()) {
				posix_fseek(file2.fp, 0);
				posix_fwrite(file2.fp, file.data, fsize);
			}
		}
		SDL_DeleteFiles(src.c_str());
	}

	// <android_prj>/app/jni/Android.mk
	if (app_in_prj != copier_.app) {
		const std::string android_mk_tmp = "Android.mk.tmp";
		src = app_android_prj_path + "/app/jni/" + android_mk_tmp;
		dst = app_android_prj_path + "/app/jni/Android.mk";
		SDL_RenameFile(dst.c_str(), android_mk_tmp.c_str());
		{
			std::vector<std::string> vstr;
			tfile file(src, GENERIC_WRITE, OPEN_EXISTING);
			int fsize = file.read_2_data();
			if (!fsize) {
				return false;
			}
			// i think length of appended data isn't more than 512 bytes.
			file.resize_data(fsize + 512, fsize);
			file.data[fsize] = '\0';

			std::string prefix;
			const char* ptr = NULL;

			if (app_in_prj != copier_.app) {
				// studio
				prefix = app_in_prj;
				ptr = strstr(file.data, prefix.c_str());
				while (ptr) {
					fsize = file.replace_span(ptr - file.data, prefix.size(), copier_.app.c_str(), copier_.app.size(), fsize);
					// replace next
					ptr = strstr(ptr, prefix.c_str());
				}
			}

			// write data to new file
			tfile file2(dst, GENERIC_WRITE, CREATE_ALWAYS);
			if (file2.valid()) {
				posix_fseek(file2.fp, 0);
				posix_fwrite(file2.fp, file.data, fsize);
			}
		}
		SDL_DeleteFiles(src.c_str());
	}

	std::string app_src_path = alias_2_path(app_src_alias);
	std::string app_src2_path = alias_2_path(app_src2_alias);
	std::replace(app_src_path.begin(), app_src_path.end(), path_sep(false), path_sep(true));
	// <app_src>/scripts/android_set_variable.tpl
	{
		std::vector<std::pair<std::string, std::string> > replaces;
		replaces.push_back(std::make_pair("%_APP_SRC%", app_src_path));
		file_replace_string(app_src_path + "/scripts/android_set_variable.tpl", app_src_path + "/scripts/android_set_variable.bat", replaces);

		tfile file2(app_src_path + "/scripts/android_set_variable.bat", GENERIC_WRITE, OPEN_EXISTING);
		int fsize = file2.read_2_data();
		// i think length of appended data isn't more than 512 bytes.
		file2.resize_data(fsize + 512, fsize);
		file2.data[fsize] = '\0';

		// app directory
		std::stringstream app_dir;
		app_dir << "\n\nset " << copier_.app << "=" << app_src2_path << "/projectfiles/android/app";
		
		std::string app_dir_str = app_dir.str();
		std::replace(app_dir_str.begin(), app_dir_str.end(), path_sep(false), path_sep(true));
		fsize = file2.replace_span(fsize, 0, app_dir_str.c_str(), app_dir_str.size(), fsize);

		posix_fseek(file2.fp, 0);
		posix_fwrite(file2.fp, file2.data, fsize);
	}
	if (!is_studio_app(copier_.app)) {
		SDL_DeleteFiles((app_src_path + "/scripts/android_set_variable.tpl").c_str());
	}

	return true;
}





void tstudio_extra_exporter::app_complete_paths()
{
	copier_.app_complete_paths(paths_);
}


void tandroid_res::app_complete_paths()
{
	copier_.app_complete_paths(paths_);
}

bool tandroid_res::app_can_execute(const tsubtask& subtask, const bool last)
{
	if (!last) {
		return true;
	}
	return is_directory(get_android_res_path());
}

bool tandroid_res::app_post_handle(display& disp, const tsubtask& subtask, const bool last)
{
	if (!last) {
		return true;
	}

	{
		// generate __cookie.cki on every directory.
		// "<apps-src/apps>/projectfiles/android/app/src/main/assets/res"
		tcopy_cookie ccp(alias_2_path(app_src2_alias) + "/projectfiles/android/app/src/main/assets/res");
		walk_dir(ccp.current_path, false, boost::bind(&tcopy_cookie::cb_copy_cookie, &ccp, _1, _2));
	}

	std::stringstream ss;
	{
		// generate __cookie.cki on every directory.
		// <blesmart-src>/projectfiles/android/<__app__>/src/main/assets/res
		tcopy_cookie ccp(get_android_res_path());
		walk_dir(ccp.current_path, false, boost::bind(&tcopy_cookie::cb_copy_cookie, &ccp, _1, _2));
	}

	return true;
}

std::vector<std::pair<std::string, std::string> > tandroid_res::app_get_replace(const tsubtask& subtask)
{
	VALIDATE(!copier_.app.empty(), null_str);

	const std::string replacee = "<__app__>";
	return std::vector<std::pair<std::string, std::string> >(1, std::make_pair(replacee, copier_.app));
}

std::string tandroid_res::get_android_res_path()
{
	std::stringstream ss;

	ss << alias_2_path(ttask::src2_alias);
	ss << "/projectfiles/android/";
	ss << copier_.app;
	ss << "/src/main/assets/res";

	return ss.str();
}


const std::string tios_kit::kit_alias = "kit";
const std::string tios_kit::studio_alias = "studio";

bool tios_kit::app_post_handle(display& disp, const tsubtask& subtask, const bool last)
{
	if (!last) {
		return true;
	}

	// const std::string& app_res_path = alias_2_path(app_res_alias)
	// const std::string& app_ios_prj_path = alias_2_path(tapp_copier::app_ios_prj_alias)
	const std::string& studio_path = alias_2_path(studio_alias);
	if (!generate_ios_prj(disp, copier_, studio_path, studio_path + "/projectfiles/Xcode-iOS")) {
		return false;
	}

	return true;
}

std::vector<std::pair<std::string, std::string> > tios_kit::app_get_replace(const tsubtask& subtask)
{
	const std::string replacee = "<__app__>";
	return std::vector<std::pair<std::string, std::string> >(1, std::make_pair(replacee, "studio"));
}


const std::string tnewer::windows_prj_alias = "windows_prj";

void tnewer::app_complete_paths()
{
	const std::string& src2_path = ::alias_2_path(paths_, ttask::src2_alias);

	paths_.insert(std::make_pair(windows_prj_alias, src2_path + "/projectfiles/windows-prj"));
}

std::vector<std::pair<std::string, std::string> > tnewer::app_get_replace(const tsubtask& subtask)
{
	VALIDATE(!app_.empty(), null_str);

	std::vector<std::pair<std::string, std::string> > ret;
	ret.push_back(std::make_pair("<__app__>", app_));
	return ret;
}



void timporter::set_app(const std::string& app, const std::string& res_path, const std::string& src2_path)
{
	app_ = app;

	set_alias(app_res_alias, res_path);
	set_alias(app_src2_alias, src2_path);
}

std::vector<std::pair<std::string, std::string> > timporter::app_get_replace(const tsubtask& subtask)
{
	VALIDATE(!app_.empty(), null_str);

	std::vector<std::pair<std::string, std::string> > ret;
	ret.push_back(std::make_pair("<__app__>", app_));
	return ret;
}


std::vector<std::pair<std::string, std::string> > tremover::app_get_replace(const tsubtask& subtask)
{
	VALIDATE(!app_.empty(), null_str);

	const std::string replacee = "<__app__>";
	return std::vector<std::pair<std::string, std::string> >(1, std::make_pair(replacee, app_));
}

bool tremover::app_post_handle(display& disp, const tsubtask& subtask, const bool last)
{
	if (!last) {
		return true;
	}

	std::vector<std::string> languages;
	walk_dir(game_config::path + "/translations", 0, 
		boost::bind(&tremover::did_language, this, _1, _2, boost::ref(languages)));

	// remove bonus *.mo
	for (std::set<std::string>::const_iterator it = tdomains_.begin(); it != tdomains_.end(); ++ it) {
		for (std::vector<std::string>::const_iterator it2 = languages.begin(); it2 != languages.end(); ++ it2) {
			const std::string file = game_config::path + "/translations/" + *it2 + "/LC_MESSAGES/" + *it + ".mo";
			SDL_DeleteFiles(file.c_str());
		}
	}

	return true;
}

bool tremover::did_language(const std::string& dir, const SDL_dirent2* dirent, std::vector<std::string>& languages)
{
	bool isdir = SDL_DIRENT_DIR(dirent->mode);
	if (isdir) {
		std::vector<std::string> vstr = utils::split(dirent->name, '_');
		if (vstr.size() == 2) {
			languages.push_back(dirent->name);
		}
	}
	return true;
}

void tnew_window::set_app(const std::string& app, const std::string& id)
{
	VALIDATE(!app.empty() && !id.empty(), null_str);

	app_ = app;
	id_ = id;
}

std::vector<std::pair<std::string, std::string> > tnew_window::app_get_replace(const tsubtask& subtask)
{
	VALIDATE(!app_.empty() && !id_.empty(), null_str);

	std::vector<std::pair<std::string, std::string> > ret;
	ret.push_back(std::make_pair("<__app__>", app_));
	ret.push_back(std::make_pair("<__id__>", id_));
	ret.push_back(std::make_pair("<__ID__>", utils::uppercase(id_)));
	return ret;
}


std::vector<std::string> tnew_dialog::sln_files()
{
	VALIDATE(!app_.empty() && !id_.empty(), null_str);

	std::vector<std::string> ret;
	ret.push_back("gui/dialogs/" + id_ + ".cpp");
	ret.push_back("gui/dialogs/" + id_ + ".hpp");

	return ret;
}

std::vector<std::string> tnew_scene::sln_files()
{
	VALIDATE(!app_.empty() && !id_.empty(), null_str);
	std::vector<std::string> ret;
	ret.push_back(id_ + "_controller.cpp");
	ret.push_back(id_ + "_controller.hpp");
	ret.push_back(id_ + "_display.cpp");
	ret.push_back(id_ + "_display.hpp");
	if (unit_files_) {
		ret.push_back("unit_map.cpp");
		ret.push_back("unit_map.hpp");
		ret.push_back("unit.cpp");
		ret.push_back("unit.hpp");
	}

	ret.push_back("gui/dialogs/" + id_ + "_scene.cpp");
	ret.push_back("gui/dialogs/" + id_ + "_scene.hpp");
	return ret;
}

bool tnew_scene::app_can_execute(const tsubtask& subtask, const bool last)
{
	return unit_files_ || subtask.id().find("unit_files") == std::string::npos;
}


const std::string tvalidater::windows_prj_alias = "windows_prj";

void tvalidater::app_complete_paths()
{
	const std::string& src2_path = ::alias_2_path(paths_, ttask::src2_alias);

	paths_.insert(std::make_pair(windows_prj_alias, src2_path + "/projectfiles/windows-prj"));
}

std::vector<std::pair<std::string, std::string> > tvalidater::app_get_replace(const tsubtask& subtask)
{
	VALIDATE(!app_.empty(), null_str);

	const std::string replacee = "<__app__>";
	return std::vector<std::pair<std::string, std::string> >(1, std::make_pair(replacee, app_));
}


const std::string tsave_theme::windows_prj_alias = "windows_prj";

void tsave_theme::app_complete_paths()
{
	const std::string& src2_path = ::alias_2_path(paths_, ttask::src2_alias);

	paths_.insert(std::make_pair(windows_prj_alias, src2_path + "/projectfiles/windows-prj"));
}

std::vector<std::pair<std::string, std::string> > tsave_theme::app_get_replace(const tsubtask& subtask)
{
	VALIDATE(!fields_.app.empty(), null_str);
	VALIDATE(!fields_.id.empty(), null_str);

	std::vector<std::pair<std::string, std::string> > ret;
	ret.push_back(std::make_pair("<__app__>", fields_.app));
	ret.push_back(std::make_pair("<__theme__>", fields_.id));
	return ret;
}

bool tsave_theme::app_post_handle(display& disp, const tsubtask& subtask, const bool last)
{
	if (!last) {
		return true;
	}

	config cfg;
	config& theme_cfg = cfg.add_child("theme");
	theme_cfg["app"] = fields_.app;
	theme_cfg["id"] = fields_.id;

	std::string prefix;
	for (int tpl = 0; tpl < theme::color_tpls; tpl ++) {
		prefix.clear();
		if (tpl == theme::inverse_tpl) {
			prefix = "inverse_";
		} else if (tpl == theme::title_tpl) {
			prefix = "title_";
		}

		theme_cfg[prefix + "normal_color"] = encode_color(fields_.text_color_tpls[tpl].normal);
		theme_cfg[prefix + "disable_color"] = encode_color(fields_.text_color_tpls[tpl].disable);
		theme_cfg[prefix + "focus_color"] = encode_color(fields_.text_color_tpls[tpl].focus);
		theme_cfg[prefix + "placeholder_color"] = encode_color(fields_.text_color_tpls[tpl].placeholder);
	}

	// other color
	theme_cfg["item_focus_color"] = encode_color(fields_.item_focus_color);
	theme_cfg["item_highlight_color"] = encode_color(fields_.item_highlight_color);
	theme_cfg["menu_focus_color"] = encode_color(fields_.menu_focus_color);

	std::stringstream ss;
	::write(ss, cfg);

	const std::string path = game_config::path + "/data/" + game_config::generate_app_dir(fields_.app) + "/theme/" + fields_.id + ".cfg";
	tfile file(path, GENERIC_WRITE, CREATE_ALWAYS);
	VALIDATE(file.valid(), null_str);
	posix_fwrite(file.fp, ss.str().c_str(), ss.str().size());

	return true;
}


const std::string tremove_theme::windows_prj_alias = "windows_prj";

void tremove_theme::app_complete_paths()
{
	const std::string& src2_path = ::alias_2_path(paths_, ttask::src2_alias);

	paths_.insert(std::make_pair(windows_prj_alias, src2_path + "/projectfiles/windows-prj"));
}

std::vector<std::pair<std::string, std::string> > tremove_theme::app_get_replace(const tsubtask& subtask)
{
	VALIDATE(!fields_.app.empty(), null_str);
	VALIDATE(!fields_.id.empty(), null_str);

	std::vector<std::pair<std::string, std::string> > ret;
	ret.push_back(std::make_pair("<__app__>", fields_.app));
	ret.push_back(std::make_pair("<__theme__>", fields_.id));
	return ret;
}
